<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Enigma 2 - Slide Puzzle</title>
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.5.10/css/pico.min.css">
  <link rel="stylesheet" href="assets/style.css?v=2025-09-24-01">
  <script src="assets/app.js?v=2025-09-24-01"></script>
</head>
<body data-page="enigma2">
  <script>initGate('enigma2', { requiredStep: 'enigma1' });</script>
  <main class="container-narrow puzzle-stage-wrapper">
    <article class="puzzle-card center-stack">
      <p class="puzzle-taunt">Ricomponi il ghigno shock o resta bloccato qui.</p>

      <section class="puzzle-info" aria-live="polite">
        <div><strong>Mosse</strong> <span id="puzzleMoves">0</span></div>
        <div><strong>Tempo</strong> <span id="puzzleTimer">10:00</span></div>
        <button type="button" id="puzzleReset" class="secondary">Rigenera puzzle</button>
      </section>

      <div class="puzzle-stage">
        <div class="puzzle-wrapper">
          <div id="slidePuzzle" class="slide-puzzle" aria-label="Puzzle a scorrimento shockFace"></div>
          <p id="puzzleStatus" class="puzzle-status" aria-live="assertive"></p>
        </div>
      </div>
    </article>
  </main>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const SIZE = 4; // 4x4 (15 puzzle)
      const TIME_LIMIT = 600; // secondi (10 minuti)
      const MOVE_PENALTY = 5; // secondi sottratti a ogni mossa
      const IMAGE_SRC = 'assets/media/shockFace.jpg';
      const puzzleEl = document.getElementById('slidePuzzle');
      const timerEl = document.getElementById('puzzleTimer');
      const moveEl = document.getElementById('puzzleMoves');
      const statusEl = document.getElementById('puzzleStatus');
      const resetBtn = document.getElementById('puzzleReset');

      if (!puzzleEl) return;

      let timeBank = TIME_LIMIT;
      let board = [];
      let emptyIndex = 0;
      let moves = 0;
      let timerId = null;
      let remaining = timeBank;
      let solved = false;

      const indexToCoord = (idx) => ({ row: Math.floor(idx / SIZE), col: idx % SIZE });
      const coordToIndex = (row, col) => row * SIZE + col;

      const formatTime = (seconds) => {
        const mm = String(Math.floor(seconds / 60)).padStart(2, '0');
        const ss = String(seconds % 60).padStart(2, '0');
        return `${mm}:${ss}`;
      };

      const updateHud = () => {
        moveEl.textContent = moves;
        timerEl.textContent = formatTime(Math.max(0, remaining));
      };

      const buildTile = (value, index) => {
        const tile = document.createElement('button');
        tile.type = 'button';
        tile.className = 'puzzle-tile';

        if (value === 0) {
          tile.classList.add('is-empty');
          tile.tabIndex = -1;
          tile.setAttribute('aria-hidden', 'true');
          tile.style.backgroundImage = 'none';
        } else {
          const homeRow = Math.floor((value - 1) / SIZE);
          const homeCol = (value - 1) % SIZE;
          const posX = ((SIZE === 1 ? 0 : homeCol / (SIZE - 1)) * 100).toFixed(4);
          const posY = ((SIZE === 1 ? 0 : homeRow / (SIZE - 1)) * 100).toFixed(4);
          tile.style.backgroundImage = `url(${IMAGE_SRC})`;
          tile.style.backgroundRepeat = 'no-repeat';
          tile.style.backgroundSize = `${SIZE * 100}% ${SIZE * 100}%`;
          tile.style.backgroundPosition = `${posX}% ${posY}%`;
          tile.setAttribute('aria-label', `Pezzo ${value}`);
        }

        tile.addEventListener('click', () => {
          if (solved) return;
          handleMove(index);
        });

        return tile;
      };

      const renderBoard = () => {
        puzzleEl.innerHTML = '';
        puzzleEl.style.setProperty('--puzzle-size', SIZE);
        board.forEach((value, index) => {
          puzzleEl.appendChild(buildTile(value, index));
        });
      };

      const isAdjacent = (i1, i2) => {
        const a = indexToCoord(i1);
        const b = indexToCoord(i2);
        return (a.row === b.row && Math.abs(a.col - b.col) === 1) || (a.col === b.col && Math.abs(a.row - b.row) === 1);
      };

      const isSolved = () => board.every((val, idx, arr) => (idx === arr.length - 1 ? val === 0 : val === idx + 1));

      const stopTimer = () => {
        if (timerId) {
          clearInterval(timerId);
          timerId = null;
        }
      };

      const triggerTimeout = () => {
        remaining = 0;
        updateHud();
        stopTimer();
        statusEl.textContent = 'Tempo scaduto! Ho rigenerato il puzzle.';
        reshuffle('timeout');
      };

      const startTimer = () => {
        stopTimer();
        remaining = timeBank;
        timerId = setInterval(() => {
          remaining -= 1;
          if (remaining <= 0) {
            triggerTimeout();
            return;
          }
          updateHud();
        }, 1000);
        updateHud();
      };

      const moveTile = (tileIndex) => {
        [board[tileIndex], board[emptyIndex]] = [board[emptyIndex], board[tileIndex]];
        emptyIndex = tileIndex;
        moves += 1;
        renderBoard();
        updateHud();
      };

      const applyMovePenalty = () => {
        if (MOVE_PENALTY <= 0) return false;
        remaining = Math.max(0, remaining - MOVE_PENALTY);
        updateHud();
        if (remaining === 0) {
          triggerTimeout();
          return true;
        }
        return false;
      };

      const handleMove = (tileIndex) => {
        if (!isAdjacent(tileIndex, emptyIndex)) return;
        moveTile(tileIndex);
        if (isSolved()) {
          solved = true;
          stopTimer();
          statusEl.textContent = 'Benvenuto tra i volti distorti.';
          setTimeout(() => goNext('enigma3.html', 'enigma3'), 700);
          return;
        }
        applyMovePenalty();
      };

      const scramble = (iterations = 250) => {
        const directions = [
          { dr: 1, dc: 0 },
          { dr: -1, dc: 0 },
          { dr: 0, dc: 1 },
          { dr: 0, dc: -1 },
        ];
        let currentEmpty = board.length - 1;
        for (let i = 0; i < iterations; i += 1) {
          const { row, col } = indexToCoord(currentEmpty);
          const neighbors = directions
            .map(({ dr, dc }) => ({ row: row + dr, col: col + dc }))
            .filter(({ row: r, col: c }) => r >= 0 && r < SIZE && c >= 0 && c < SIZE)
            .map(({ row: r, col: c }) => coordToIndex(r, c));
          const pick = neighbors[Math.floor(Math.random() * neighbors.length)];
          [board[pick], board[currentEmpty]] = [board[currentEmpty], board[pick]];
          currentEmpty = pick;
        }
        emptyIndex = currentEmpty;
      };

      const reshuffle = (reason = 'manual') => {
        solved = false;
        moves = 0;
        if (reason === 'timeout') {
          timeBank += 300;
        }
        if (reason !== 'timeout') {
          statusEl.textContent = '';
        }
        board = Array.from({ length: SIZE * SIZE }, (_, idx) => (idx === SIZE * SIZE - 1 ? 0 : idx + 1));
        emptyIndex = board.length - 1;
        scramble();
        renderBoard();
        startTimer();
      };

      resetBtn?.addEventListener('click', () => reshuffle('manual'));

      document.addEventListener('keydown', (event) => {
        if (solved) return;
        const { key } = event;
        let target = null;
        if (key === 'ArrowUp') target = emptyIndex + SIZE;
        if (key === 'ArrowDown') target = emptyIndex - SIZE;
        if (key === 'ArrowLeft' && emptyIndex % SIZE < SIZE - 1) target = emptyIndex + 1;
        if (key === 'ArrowRight' && emptyIndex % SIZE > 0) target = emptyIndex - 1;
        if (target != null && target >= 0 && target < board.length) {
          event.preventDefault();
          handleMove(target);
        }
      });

      reshuffle('manual');
    });
  </script>
</body>
</html>













